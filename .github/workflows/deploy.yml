name: Deploy Healthcare Backend

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  actions: read
  deployments: write

env:
  DOCKER_COMPOSE_VERSION: v2.20.2
  SERVER_HOST: api.ishswami.in
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  DEPLOY_PATH: /var/www/healthcare/backend
  SERVER_IP: 82.208.20.16
  DOMAIN: api.ishswami.in
  FRONTEND_DOMAIN: ishswami.in
  SSL_EMAIL: aadeshbhujbal99@gmail.com
  NODE_ENV: production

jobs:
  pre-deployment-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check domain DNS and SSL
        run: |
          echo "Checking DNS for ${{ env.DOMAIN }}..."
          if ! nslookup ${{ env.DOMAIN }} > /dev/null 2>&1; then
            echo "Warning: Domain ${{ env.DOMAIN }} DNS resolution failed"
            echo "Please ensure domain is properly configured"
            exit 1
          fi

          echo "Checking SSL certificate expiry..."
          expiry=$(echo | openssl s_client -servername ${{ env.DOMAIN }} -connect ${{ env.DOMAIN }}:443 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          if [ ! -z "$expiry" ]; then
            expiry_sec=$(date -d "$expiry" +%s)
            now_sec=$(date +%s)
            days_left=$(( ($expiry_sec - $now_sec) / 86400 ))
            if [ $days_left -lt 30 ]; then
              echo "Warning: SSL certificate will expire in $days_left days"
            fi
          fi

      - name: Check server connectivity and resources
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            echo "Checking system resources..."
            df -h
            free -m
            docker system df

            echo "Checking Docker status..."
            if ! docker info > /dev/null 2>&1; then
              echo "Docker is not running!"
              exit 1
            fi

            echo "Checking required ports..."
            for port in 8088 5432 6379 8082; do
              if netstat -tuln | grep -q ":$port "; then
                echo "Warning: Port $port is already in use"
                netstat -tuln | grep ":$port "
              fi
            done

            echo "Checking disk space..."
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 85 ]; then
              echo "Warning: Disk usage is above 85%"
              df -h /
            fi

            echo "Checking SSL certificate paths..."
            for dir in "/etc/nginx/ssl" "/app/ssl"; do
              if [ ! -d "$dir" ]; then
                echo "Creating $dir directory..."
                sudo mkdir -p $dir
                sudo chmod 755 $dir
              fi
            done

  create-deployment:
    needs: [pre-deployment-check]
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.create_deployment.outputs.deployment_id }}
    steps:
      - name: Create GitHub deployment
        id: create_deployment
        uses: actions/github-script@v6
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.id;

  deploy:
    needs: create-deployment
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Fix file permissions
        run: |
          chmod +x nginx/deploy-nginx.sh
          git add nginx/deploy-nginx.sh
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"
          git commit -m "chore: Make deploy-nginx.sh executable" || true

      - name: Create backup and cleanup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Create backup directory with timestamp
            timestamp=$(date +%Y%m%d_%H%M%S)
            mkdir -p backups/$timestamp

            # Stop and backup current deployment if it exists
            if [ -d "current" ] && [ -f "current/docker-compose.prod.yml" ]; then
              echo "Stopping current deployment..."
              cd current
              docker compose -f docker-compose.prod.yml down --remove-orphans || true
              cd ..

              echo "Creating backup..."
              cp -r current/* backups/$timestamp/ 2>/dev/null || true
              echo $timestamp > backups/latest_backup
              
              # Backup SSL certificates
              if [ -d "current/nginx/ssl" ]; then
                mkdir -p backups/$timestamp/ssl
                cp -r current/nginx/ssl/* backups/$timestamp/ssl/ 2>/dev/null || true
              fi

              # Clean up old backups (keep last 5)
              ls -1t backups | tail -n +6 | xargs -r rm -rf
            else
              echo "No current deployment found, proceeding with fresh deployment..."
            fi

            # Clean up Docker resources
            echo "Cleaning up Docker resources..."
            docker system prune -f
            docker volume prune -f
            docker network prune -f

            # Remove any existing containers with conflicting names
            for container in latest-redis latest-postgres latest-api latest-redis-commander; do
              if docker ps -a --format '{{.Names}}' | grep -q "^$container$"; then
                echo "Removing existing container: $container"
                docker rm -f $container || true
              fi
            done

            # Additional cleanup for any containers with the same name pattern
            echo "Cleaning up any remaining containers with similar names..."
            docker ps -a --format '{{.Names}}' | grep -E '^(latest|.*-redis-commander)$' | while read container; do
              echo "Removing container: $container"
              docker rm -f $container || true
            done

            # Create necessary directories if they don't exist
            mkdir -p current
            mkdir -p releases
            mkdir -p backups

      - name: Prepare SSL files
        run: |
          # Create SSL directories
          mkdir -p ssl_temp
          # Copy and rename certificates
          cp nginx/ssl/ishswami.com.pem ssl_temp/api.ishswami.in.crt
          cp nginx/ssl/ishswami.com.key ssl_temp/api.ishswami.in.key

          # Verify SSL certificate
          echo "Verifying SSL certificate..."
          if ! openssl x509 -in ssl_temp/api.ishswami.in.crt -noout -text > /dev/null; then
            echo "Error: Invalid SSL certificate"
            exit 1
          fi

          # Check certificate matches private key
          echo "Checking certificate and key match..."
          cert_mod=$(openssl x509 -noout -modulus -in ssl_temp/api.ishswami.in.crt | openssl md5)
          key_mod=$(openssl rsa -noout -modulus -in ssl_temp/api.ishswami.in.key | openssl md5)
          if [ "$cert_mod" != "$key_mod" ]; then
            echo "Error: Certificate and private key do not match"
            exit 1
          fi

      - name: Copy SSL certificates
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          source: "ssl_temp/*"
          target: "/tmp/ssl-temp"
          strip_components: 1

      - name: Copy deployment files
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          source: "."
          target: "${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}"
          strip_components: 0
          overwrite: true
          rm: false

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}

            # Setup SSL directories with proper permissions
            echo "Setting up SSL directories..."
            sudo mkdir -p /etc/nginx/ssl
            sudo mkdir -p /app/ssl
            sudo chown -R root:root /etc/nginx/ssl /app/ssl
            sudo chmod 755 /etc/nginx/ssl /app/ssl

            # Copy and secure SSL certificates
            if [ -d "/tmp/ssl-temp" ]; then
              echo "Copying SSL certificates..."
              sudo cp -f /tmp/ssl-temp/* /etc/nginx/ssl/
              sudo cp -f /tmp/ssl-temp/* /app/ssl/
              sudo chown root:root /etc/nginx/ssl/* /app/ssl/*
              sudo chmod 600 /etc/nginx/ssl/*.key /app/ssl/*.key
              sudo chmod 644 /etc/nginx/ssl/*.crt /app/ssl/*.crt
              rm -rf /tmp/ssl-temp
            else
              echo "No SSL files found in temp directory"
              exit 1
            fi

            # Verify SSL files and permissions
            echo "Verifying SSL files..."
            for file in /app/ssl/api.ishswami.in.key /app/ssl/api.ishswami.in.crt; do
              if [ ! -f "$file" ]; then
                echo "Error: SSL file $file not found"
                exit 1
              fi
              
              # Check permissions
              perms=$(stat -c "%a" $file)
              if [[ $file == *.key && $perms != "600" ]]; then
                echo "Error: Incorrect permissions on $file"
                exit 1
              elif [[ $file == *.crt && $perms != "644" ]]; then
                echo "Error: Incorrect permissions on $file"
                exit 1
              fi
            done

            # Start Docker services
            echo "Starting Docker services..."
            DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 docker compose -f docker-compose.prod.yml build --no-cache --parallel

            echo "Starting containers..."
            DEPLOY_SHA=$DEPLOY_SHA docker compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            echo "Waiting for services to be healthy..."
            attempt=1
            max_attempts=30
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Checking API health..."
              
              # First check if container is running
              if ! docker ps | grep -q latest-api; then
                echo "API container is not running"
                docker ps -a
                exit 1
              fi
              
              # Install necessary tools in the container
              echo "Installing necessary tools..."
              docker exec latest-api apk add --no-cache curl net-tools lsof procps strace gdb
              
              # Check if API process is running
              echo "Checking API process..."
              if ! docker exec latest-api ps aux | grep -q "node.*main"; then
                echo "API process is not running"
                echo "Current processes:"
                docker exec latest-api ps aux
                echo "Container logs:"
                docker logs latest-api
                exit 1
              fi
              
              # Get detailed process information
              echo "Getting detailed process information..."
              docker exec latest-api ps aux | grep "node.*main"
              docker exec latest-api lsof -i :8088
              
              # Check Node.js process state
              echo "Checking Node.js process state..."
              docker exec latest-api sh -c 'ps -o pid,ppid,pgid,sid,comm,state,etime,cmd -p $(pgrep -f "node.*main")'
              
              # Check Node.js process memory
              echo "Checking Node.js process memory..."
              docker exec latest-api sh -c 'pmap -x $(pgrep -f "node.*main")'
              
              # Check Node.js process environment
              echo "Checking Node.js process environment..."
              docker exec latest-api sh -c 'cat /proc/$(pgrep -f "node.*main")/environ | tr "\0" "\n"'
              
              # Check Node.js process limits
              echo "Checking Node.js process limits..."
              docker exec latest-api sh -c 'cat /proc/$(pgrep -f "node.*main")/limits'
              
              # Monitor Node.js process in background
              echo "Starting Node.js process monitoring..."
              docker exec latest-api sh -c 'strace -f -p $(pgrep -f "node.*main") 2>&1 > /tmp/node-strace.log &'
              docker exec latest-api sh -c 'top -b -n 1 -p $(pgrep -f "node.*main") > /tmp/node-top.log &'
              
              # Enable Node.js debugging
              echo "Enabling Node.js debugging..."
              docker exec latest-api sh -c 'kill -SIGUSR1 $(pgrep -f "node.*main")'
              docker exec latest-api sh -c 'node --inspect-brk=0.0.0.0:9229 dist/main > /tmp/node-debug.log 2>&1 &'
              
              # Check if port is listening
              echo "Checking if port 8088 is listening..."
              if ! docker exec latest-api netstat -tuln | grep -q ":8088"; then
                echo "Port 8088 is not listening"
                echo "Current listening ports:"
                docker exec latest-api netstat -tuln
                echo "Container logs:"
                docker logs latest-api
                
                # Check if API is still starting up
                if [ $attempt -lt 10 ]; then
                  echo "API might still be starting up, waiting..."
                  echo "Current API logs:"
                  docker logs latest-api
                  echo "Checking API process state:"
                  docker exec latest-api ps aux | grep "node.*main"
                  echo "Checking open files:"
                  docker exec latest-api lsof -p $(docker exec latest-api pgrep -f "node.*main")
                  echo "Checking Node.js process output:"
                  docker exec latest-api cat /tmp/node-strace.log
                  docker exec latest-api cat /tmp/node-top.log
                  docker exec latest-api cat /tmp/node-debug.log
                  sleep 20
                  attempt=$((attempt + 1))
                  continue
                fi
                
                # Check container environment
                echo "Container environment:"
                docker exec latest-api env
                
                # Check container network settings
                echo "Container network settings:"
                docker exec latest-api ip addr
                
                # Check container configuration
                echo "Container configuration:"
                docker inspect latest-api
                
                # Check container logs with timestamps
                echo "Container logs with timestamps:"
                docker logs --timestamps latest-api
                
                # Check API startup logs
                echo "API startup logs:"
                docker exec latest-api cat /app/logs/startup.log 2>/dev/null || echo "No startup logs found"
                
                # Check API process state
                echo "API process state:"
                docker exec latest-api ps aux | grep "node.*main"
                docker exec latest-api lsof -p $(docker exec latest-api pgrep -f "node.*main")
                
                # Check Node.js process output
                echo "Node.js process output:"
                docker exec latest-api cat /tmp/node-strace.log
                docker exec latest-api cat /tmp/node-top.log
                docker exec latest-api cat /tmp/node-debug.log
                
                exit 1
              fi
              
              # Check API health using curl with verbose output and timeout
              echo "Checking API health..."
              container_response=$(docker exec latest-api curl -v --connect-timeout 5 --max-time 10 http://localhost:8088/health 2>&1)
              container_status=$?
              
              if [ $container_status -eq 0 ] && echo "$container_response" | grep -q "ok"; then
                echo "API is healthy from within container"
                echo "Response: $container_response"
                
                # Now try external access
                echo "Testing external access..."
                external_response=$(curl -v --connect-timeout 5 --max-time 10 http://0.0.0.0:8088/health 2>&1)
                external_status=$?
                
                if [ $external_status -eq 0 ] && echo "$external_response" | grep -q "ok"; then
                  echo "API is healthy from external access"
                  echo "Response: $external_response"
                  break
                else
                  echo "API is healthy internally but external access failed"
                  echo "External response: $external_response"
                  echo "External status: $external_status"
                  
                  # Check network configuration
                  echo "Checking network configuration..."
                  docker network inspect 16a5b06b85a89286f858b5cfc661de229e108911_app-network
                  docker inspect latest-api
                  
                  # Check container network settings
                  echo "Checking container network settings..."
                  docker exec latest-api ip addr
                  docker exec latest-api netstat -tuln
                  
                  # Check container processes
                  echo "Checking container processes..."
                  docker exec latest-api ps aux
                  
                  # Check container environment
                  echo "Checking container environment..."
                  docker exec latest-api env
                  
                  # Check container logs
                  echo "Container logs:"
                  docker logs latest-api
                  
                  # Check Node.js process output
                  echo "Node.js process output:"
                  docker exec latest-api cat /tmp/node-strace.log
                  docker exec latest-api cat /tmp/node-top.log
                  docker exec latest-api cat /tmp/node-debug.log
                fi
              else
                echo "API is not healthy from within container"
                echo "Container response: $container_response"
                echo "Container status: $container_status"
                
                # Get API container logs
                echo "API container logs:"
                docker compose -f docker-compose.prod.yml logs api
                docker logs latest-api
                
                # Check container network settings
                echo "Checking container network settings..."
                docker exec latest-api ip addr
                docker exec latest-api netstat -tuln
                
                # Check container processes
                echo "Checking container processes..."
                docker exec latest-api ps aux
                
                # Check container environment
                echo "Checking container environment..."
                docker exec latest-api env
                
                # Check Node.js process output
                echo "Node.js process output:"
                docker exec latest-api cat /tmp/node-strace.log
                docker exec latest-api cat /tmp/node-top.log
                docker exec latest-api cat /tmp/node-debug.log
              fi
              
              sleep 10
              attempt=$((attempt + 1))
            done

            if [ $attempt -gt $max_attempts ]; then
              echo "Error: API service failed to become healthy"
              
              # Get detailed container information
              echo "Container status:"
              docker ps -a
              
              echo "API container logs:"
              docker compose -f docker-compose.prod.yml logs api
              docker logs latest-api
              
              echo "Network configuration:"
              docker network inspect 16a5b06b85a89286f858b5cfc661de229e108911_app-network
              
              echo "API container details:"
              docker inspect latest-api
              
              echo "Container network settings:"
              docker exec latest-api ip addr
              docker exec latest-api netstat -tuln
              
              echo "Container processes:"
              docker exec latest-api ps aux
              
              echo "Container environment:"
              docker exec latest-api env
              
              # Check Node.js process output
              echo "Node.js process output:"
              docker exec latest-api cat /tmp/node-strace.log
              docker exec latest-api cat /tmp/node-top.log
              docker exec latest-api cat /tmp/node-debug.log
              
              exit 1
            fi

            # Remove obsolete version attribute from docker-compose.prod.yml
            echo "Removing obsolete version attribute from docker-compose.prod.yml..."
            sed -i '/^version:/d' docker-compose.prod.yml

            # Verify SSL configuration
            echo "Verifying SSL configuration..."
            if ! curl -k -s -o /dev/null -w "%{http_code}" https://localhost:8088/health | grep -q "200"; then
              echo "Error: SSL configuration test failed"
              exit 1
            fi

            # Update current deployment symlink
            cd ${{ env.DEPLOY_PATH }}
            rm -f current
            ln -sfn releases/${{ github.sha }} current
            echo ${{ github.sha }} > current_deployment

            echo "Deployment completed successfully"

  post-deployment-verification:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Verify domain and SSL
        run: |
          echo "Verifying domain and SSL configuration..."

          # Check DNS resolution
          if ! nslookup ${{ env.DOMAIN }} > /dev/null 2>&1; then
            echo "Error: Domain ${{ env.DOMAIN }} is not resolving"
            exit 1
          fi

          # Check SSL certificate
          echo "Checking SSL certificate..."
          if ! openssl s_client -connect ${{ env.DOMAIN }}:443 -servername ${{ env.DOMAIN }} < /dev/null 2>&1 | grep -q "Verify return code: 0"; then
            echo "Error: SSL certificate verification failed"
            exit 1
          fi

          # Check SSL certificate expiry
          expiry=$(echo | openssl s_client -servername ${{ env.DOMAIN }} -connect ${{ env.DOMAIN }}:443 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          if [ ! -z "$expiry" ]; then
            expiry_sec=$(date -d "$expiry" +%s)
            now_sec=$(date +%s)
            days_left=$(( ($expiry_sec - $now_sec) / 86400 ))
            if [ $days_left -lt 30 ]; then
              echo "Warning: SSL certificate will expire in $days_left days"
            fi
          fi

      - name: Verify Nginx configuration
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e

            echo "Verifying Nginx configuration..."

            # Check Nginx configuration syntax
            if ! sudo nginx -t; then
              echo "Error: Nginx configuration test failed"
              exit 1
            fi

            # Check Nginx is running
            if ! systemctl is-active --quiet nginx; then
              echo "Error: Nginx is not running"
              exit 1
            fi

            # Check SSL certificate paths and permissions
            for file in /etc/nginx/ssl/api.ishswami.in.key /etc/nginx/ssl/api.ishswami.in.crt; do
              if [ ! -f "$file" ]; then
                echo "Error: SSL file $file not found"
                exit 1
              fi
              
              perms=$(stat -c "%a" $file)
              if [[ $file == *.key && $perms != "600" ]]; then
                echo "Error: Incorrect permissions on $file"
                exit 1
              elif [[ $file == *.crt && $perms != "644" ]]; then
                echo "Error: Incorrect permissions on $file"
                exit 1
              fi
            done

            # Check Nginx virtual host configuration
            if [ ! -f "/etc/nginx/conf.d/api.ishswami.in.conf" ]; then
              echo "Error: Nginx virtual host configuration not found"
              exit 1
            fi

            # Check SSL configuration in Nginx
            if ! grep -q "ssl_certificate" /etc/nginx/conf.d/api.ishswami.in.conf || \
               ! grep -q "ssl_certificate_key" /etc/nginx/conf.d/api.ishswami.in.conf; then
              echo "Error: SSL configuration missing in Nginx"
              exit 1
            fi

      - name: Verify application health
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e

            echo "Verifying application health..."

            # Check API health endpoint
            if ! curl -k -s https://${{ env.DOMAIN }}/health | grep -q "ok"; then
              echo "Error: API health check failed"
              exit 1
            fi

            # Check Redis Commander
            if ! curl -k -s https://${{ env.DOMAIN }}:8082 | grep -q "Redis Commander"; then
              echo "Error: Redis Commander health check failed"
              exit 1
            fi

            # Check database connection
            if ! docker exec ${{ env.DEPLOY_PATH }}/current/postgres pg_isready -U postgres; then
              echo "Error: Database health check failed"
              exit 1
            fi

            # Check Redis connection
            if ! docker exec ${{ env.DEPLOY_PATH }}/current/redis redis-cli ping | grep -q "PONG"; then
              echo "Error: Redis health check failed"
              exit 1
            fi

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.create-deployment.outputs.deployment_id }},
              state: status,
              environment: 'production'
            });

  rollback:
    if: failure() && (needs.deploy.result == 'failure' || needs.post-deployment-verification.result == 'failure')
    needs: [deploy, post-deployment-verification, create-deployment]
    runs-on: ubuntu-latest
    steps:
      - name: Rollback deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            if [ -f backups/latest_backup ]; then
              timestamp=$(cat backups/latest_backup)
              echo "Rolling back to backup from $timestamp"

              # Stop current services
              if [ -d "current" ]; then
                cd current
                docker compose -f docker-compose.prod.yml down --remove-orphans || true
                cd ..
              fi

              # Clean up Docker resources
              echo "Cleaning up Docker resources..."
              docker system prune -f
              docker volume prune -f
              docker network prune -f

              # Restore from backup
              rm -rf current
              cp -r backups/$timestamp current/

              # Start services from backup
              cd current
              docker compose -f docker-compose.prod.yml up -d

              # Wait for services to be healthy
              echo "Waiting for services to be healthy..."
              attempt=1
              max_attempts=30
              while [ $attempt -le $max_attempts ]; do
                if curl -k -s https://localhost:8088/health | grep -q "ok"; then
                  echo "API service is healthy"
                  break
                fi
                echo "Attempt $attempt/$max_attempts: Waiting for API service..."
                sleep 10
                attempt=$((attempt + 1))
              done

              if [ $attempt -gt $max_attempts ]; then
                echo "Error: API service failed to become healthy after rollback"
                docker compose -f docker-compose.prod.yml logs api
                exit 1
              fi

              echo "Rollback completed successfully"
            else
              echo "No backup found for rollback"
              exit 1
            fi

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.create-deployment.outputs.deployment_id }},
              state: status,
              environment: 'production'
            });
