name: Deploy Healthcare Backend

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  actions: read
  deployments: write

env:
  DOCKER_COMPOSE_VERSION: v2.20.2
  SERVER_HOST: api.ishswami.in
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  DEPLOY_PATH: /var/www/healthcare/backend
  SERVER_IP: 82.208.20.16
  DOMAIN: api.ishswami.in
  FRONTEND_DOMAIN: ishswami.in
  SSL_EMAIL: aadeshbhujbal99@gmail.com
  NODE_ENV: production
  API_URL: https://api.ishswami.in
  API_CONTAINER: latest-api
  POSTGRES_CONTAINER: latest-postgres
  REDIS_CONTAINER: latest-redis
  REDIS_COMMANDER_CONTAINER: latest-redis-commander
  NETWORK_NAME: app-network

jobs:
  pre-deployment-check:
    runs-on: ubuntu-latest
    steps:
      - name: Test SSH connection
        run: |
          echo "Testing SSH connection to ${{ env.SERVER_IP }}..."
          # Create SSH key file
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Add server to known hosts and test connection with timeout
          ssh-keyscan -H ${{ env.SERVER_IP }} >> ~/.ssh/known_hosts
          if timeout 30s ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} "echo SSH connection successful"; then
            echo "✅ SSH connection successful"
          else
            echo "❌ SSH connection failed"
            echo "Attempting to ping server..."
            ping -c 4 ${{ env.SERVER_IP }}
            exit 1
          fi

      - name: Check domain DNS
        run: |
          echo "Checking DNS for ${{ env.DOMAIN }}..."
          if ! nslookup ${{ env.DOMAIN }} > /dev/null 2>&1; then
            echo "Warning: Domain ${{ env.DOMAIN }} DNS resolution failed"
            echo "Please ensure domain is properly configured"
            # Don't exit with error as this is just a warning
            echo "Continuing deployment despite DNS warning..."
          else
            echo "Domain ${{ env.DOMAIN }} resolves correctly"
          fi

      - name: Check server connectivity
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          debug: true
          timeout: 60s
          command_timeout: "30m"
          script: |
            echo "Testing connection to server..."
            echo "Current date and time: $(date)"
            echo "Server IP: $(hostname -I || echo 'hostname command not available')"
            echo "Checking system resources..."
            df -h
            free -m

            # Don't exit if Docker system df fails (first deployment)
            echo "Checking Docker status..."
            docker system df || echo "Docker may not be initialized yet, continuing..."

            echo "Checking required ports..."
            # Use netstat if available, otherwise skip
            if command -v netstat &> /dev/null; then
              for port in 8088 5432 6379 8082; do
                if netstat -tuln | grep -q ":$port "; then
                  echo "Warning: Port $port is already in use"
                  netstat -tuln | grep ":$port "
                else
                  echo "Port $port is available"
                fi
              done
            else
              echo "netstat not available, skipping port check"
            fi

            echo "Checking disk space..."
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 85 ]; then
              echo "Warning: Disk usage is above 85%"
              df -h /
            else
              echo "Disk space is sufficient"
            fi

  create-deployment:
    needs: [pre-deployment-check]
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ github.run_id }}
    steps:
      - name: Create deployment marker
        run: echo "Creating deployment with ID ${{ github.run_id }}"

  deploy:
    needs: create-deployment
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Create backup and cleanup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          debug: true
          timeout: 60s
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Create backup directory with timestamp
            timestamp=$(date +%Y%m%d_%H%M%S)
            mkdir -p backups/$timestamp

            # Stop and backup current deployment if it exists
            if [ -d "current" ] && [ -f "current/docker-compose.prod.yml" ]; then
              echo "Stopping current deployment..."
              cd current
              docker compose -f docker-compose.prod.yml down --remove-orphans || true
              cd ..

              echo "Creating backup..."
              cp -r current/* backups/$timestamp/ 2>/dev/null || true
              echo $timestamp > backups/latest_backup
            else
              echo "No current deployment found, proceeding with fresh deployment..."
            fi

            # Clean up Docker resources
            echo "Cleaning up Docker resources..."
            docker system prune -f
            docker volume prune -f

            # Remove any existing containers with conflicting names
            for container in latest-redis latest-postgres latest-api latest-redis-commander; do
              if docker ps -a --format '{{.Names}}' | grep -q "^$container$"; then
                echo "Removing existing container: $container"
                docker rm -f $container || true
              fi
            done

            # Create necessary Docker network if it doesn't exist
            echo "Creating Docker network..."
            if ! docker network inspect app-network > /dev/null 2>&1; then
              docker network create app-network --subnet=172.18.0.0/16
            fi

            # Create necessary directories if they don't exist
            mkdir -p current
            mkdir -p releases
            mkdir -p backups

      - name: Prepare deployment files
        run: |
          echo "Preparing files for deployment..."
          echo "Current directory: $PWD"
          echo "GitHub workspace: $GITHUB_WORKSPACE"

          # Create a temporary deployment directory
          rm -rf deploy_temp
          mkdir -p deploy_temp

          # Copy required directories and files
          echo "Copying deployment files..."
          cp -r src nginx deploy_temp/
          cp docker-compose.prod.yml .env.production Dockerfile package*.json tsconfig*.json deploy_temp/

      - name: Copy deployment files
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          source: "deploy_temp/*"
          target: "${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}"
          strip_components: 1
          overwrite: true
          rm: false

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}

            # Configure host to resolve api.ishswami.in to localhost
            echo "Configuring hosts file for api.ishswami.in..."
            if ! grep -q "api.ishswami.in" /etc/hosts; then
              echo "127.0.0.1 api.ishswami.in" | sudo tee -a /etc/hosts
            fi

            # Make sure api.ishswami.in is also registered on the server's public IP
            echo "Ensuring domain is properly configured on server..."
            SERVER_IP=$(curl -s ifconfig.me)
            if ! grep -q "$SERVER_IP api.ishswami.in" /etc/hosts; then
              echo "$SERVER_IP api.ishswami.in" | sudo tee -a /etc/hosts
            fi

            # Handle Docker network
            echo "Setting up Docker network..."
            if ! docker network inspect app-network > /dev/null 2>&1; then
              echo "Creating Docker network app-network..."
              docker network create app-network --subnet=172.18.0.0/16
            fi

            # Check if Nginx is installed and configured
            echo "Checking Nginx installation..."
            if ! command -v nginx &> /dev/null; then
              echo "Nginx not found, installing..."
              sudo apt-get update
              sudo apt-get install -y nginx
            fi

            # Ensure required directories exist
            echo "Setting up directories..."
            sudo mkdir -p /etc/nginx/conf.d
            sudo mkdir -p /var/www/healthcare/frontend/current
            sudo chown -R www-data:www-data /var/www/healthcare

            # Check if SSL is already configured, otherwise set it up
            echo "Checking SSL configuration..."

            # First, check if certbot is installed, install if not
            if ! command -v certbot &> /dev/null; then
              echo "Installing certbot..."
              sudo apt-get update
              sudo apt-get install -y certbot python3-certbot-nginx
            else
              echo "Certbot is already installed."
              # Make sure the nginx plugin is installed
              if ! sudo certbot plugins | grep -q "nginx"; then
                echo "Installing certbot-nginx plugin..."
                sudo apt-get update
                sudo apt-get install -y python3-certbot-nginx
              fi
            fi

            # Check for Let's Encrypt certificates
            if [ ! -f /etc/letsencrypt/live/api.ishswami.in/fullchain.pem ]; then
              echo "Let's Encrypt certificates not found, generating new ones..."
              
              # Get certificates using DNS validation
              echo "Getting Let's Encrypt certificates for the first time..."
              sudo certbot --nginx -d api.ishswami.in --non-interactive --agree-tos --email ${{ env.SSL_EMAIL }} || {
                echo "Let's Encrypt certificate generation failed, creating a fallback self-signed certificate..."
                sudo mkdir -p /etc/ssl/certs/nginx
                
                # Generate a stronger self-signed certificate with proper SANs
                echo "Generating self-signed certificate..."
                # Create a simpler command that doesn't require a config file
                sudo openssl req -x509 -nodes -days 365 -newkey rsa:4096 \
                  -keyout /etc/ssl/certs/nginx/nginx-selfsigned.key \
                  -out /etc/ssl/certs/nginx/nginx-selfsigned.crt \
                  -subj "/C=IN/ST=Delhi/L=Delhi/O=HealthCare/OU=IT/CN=api.ishswami.in" \
                  -addext "subjectAltName=DNS:api.ishswami.in,DNS:ishswami.in,IP:${{ env.SERVER_IP }}"
                
                # Set correct permissions
                sudo chmod 600 /etc/ssl/certs/nginx/nginx-selfsigned.key
                sudo chmod 644 /etc/ssl/certs/nginx/nginx-selfsigned.crt
                
                # Update Nginx configuration to use self-signed certificates
                echo "Updating Nginx configuration for self-signed certificates..."
                sudo sed -i 's|ssl_certificate /etc/letsencrypt/live/api.ishswami.in/fullchain.pem|ssl_certificate /etc/ssl/certs/nginx/nginx-selfsigned.crt|g' /etc/nginx/conf.d/server.conf
                sudo sed -i 's|ssl_certificate_key /etc/letsencrypt/live/api.ishswami.in/privkey.pem|ssl_certificate_key /etc/ssl/certs/nginx/nginx-selfsigned.key|g' /etc/nginx/conf.d/server.conf
                sudo sed -i 's|ssl_stapling on|ssl_stapling off|g' /etc/nginx/conf.d/server.conf
                sudo sed -i 's|ssl_stapling_verify on|# ssl_stapling_verify off|g' /etc/nginx/conf.d/server.conf
                
                echo "Using self-signed certificate as fallback."
              }
              
              # Set up automatic renewal if we successfully got certificates
              if [ -f /etc/letsencrypt/live/api.ishswami.in/fullchain.pem ]; then
                echo "Setting up auto-renewal for Let's Encrypt certificates..."
                
                # Check if renewal cron job already exists
                if ! sudo crontab -l | grep -q 'certbot renew'; then
                  # Add cron job for certificate renewal
                  (sudo crontab -l 2>/dev/null; echo "0 3 * * * certbot renew --quiet --post-hook 'systemctl reload nginx'") | sudo crontab -
                  echo "Added certificate renewal cron job."
                else
                  echo "Certificate renewal cron job already exists."
                fi
              fi
            else
              echo "Using existing Let's Encrypt certificates."
              
              # Check if certificate is valid and not expiring soon
              CERT_EXPIRY=$(sudo openssl x509 -enddate -noout -in /etc/letsencrypt/live/api.ishswami.in/fullchain.pem | cut -d= -f2)
              EXPIRY_DATE=$(sudo date -d "$CERT_EXPIRY" +%s)
              CURRENT_DATE=$(date +%s)
              DAYS_LEFT=$(( ($EXPIRY_DATE - $CURRENT_DATE) / 86400 ))
              
              echo "Certificate expires in $DAYS_LEFT days."
              
              # Only attempt renewal if less than 30 days left
              if [ "$DAYS_LEFT" -lt 30 ]; then
                echo "Certificate expires soon. Attempting renewal..."
                sudo certbot renew --quiet
                
                # Check if renewal succeeded
                if [ $? -eq 0 ]; then
                  echo "Certificate renewal succeeded."
                  sudo systemctl reload nginx
                else
                  echo "Certificate renewal failed. Will try again later."
                fi
              else
                echo "Certificate is still valid. No renewal needed."
              fi
              
              # Ensure auto-renewal is set up
              if ! sudo crontab -l | grep -q 'certbot renew'; then
                echo "Setting up auto-renewal for existing certificates..."
                (sudo crontab -l 2>/dev/null; echo "0 3 * * * certbot renew --quiet --post-hook 'systemctl reload nginx'") | sudo crontab -
                echo "Added certificate renewal cron job."
              fi
            fi

            # Copy Nginx configuration only if it doesn't exist or if it's different
            echo "Checking Nginx configuration..."

            # Create a temporary copy to compare
            sudo cp -f nginx/conf.d/server.conf /tmp/new_server.conf

            # Update SSL paths in the new config to use self-signed certificates
            sudo sed -i 's|ssl_certificate /etc/letsencrypt/live/api.ishswami.in/fullchain.pem|ssl_certificate /etc/ssl/certs/nginx/nginx-selfsigned.crt|g' /tmp/new_server.conf
            sudo sed -i 's|ssl_certificate_key /etc/letsencrypt/live/api.ishswami.in/privkey.pem|ssl_certificate_key /etc/ssl/certs/nginx/nginx-selfsigned.key|g' /tmp/new_server.conf

            # Check if configuration file exists and is different
            if [ ! -f /etc/nginx/conf.d/server.conf ] || ! sudo diff -q /tmp/new_server.conf /etc/nginx/conf.d/server.conf >/dev/null; then
              echo "Updating Nginx configuration..."
              sudo cp -f /tmp/new_server.conf /etc/nginx/conf.d/server.conf
              
              # Remove any conflicting configurations
              sudo rm -f /etc/nginx/conf.d/api.ishswami.in.conf
              
              # Testing Nginx configuration
              echo "Testing Nginx configuration..."
              # Temporarily disable ssl_stapling for self-signed certs
              if [ -f /etc/ssl/certs/nginx/nginx-selfsigned.crt ]; then
                echo "Using self-signed cert, temporarily disabling ssl_stapling..."
                sudo sed -i 's/ssl_stapling on/ssl_stapling off/g' /etc/nginx/conf.d/server.conf
                sudo sed -i 's/ssl_stapling_verify on/# ssl_stapling_verify off/g' /etc/nginx/conf.d/server.conf
              fi
              
              if ! sudo nginx -t; then
                echo "Nginx configuration test failed, check server.conf"
                exit 1
              fi
              
              # Reload Nginx instead of restarting to minimize downtime
              echo "Reloading Nginx..."
              sudo systemctl reload nginx || sudo systemctl restart nginx
            else
              echo "Nginx configuration unchanged, skipping update."
            fi

            # Clean up temporary files
            sudo rm -f /tmp/new_server.conf

            # Create a default index.html if frontend doesn't exist
            if [ ! -f /var/www/healthcare/frontend/current/index.html ]; then
              echo "Creating a default index.html..."
              echo '<html><body><h1>HealthCare API Server</h1><p>API is running. Frontend not deployed yet.</p><p><a href="/health">API Health Check</a></p></body></html>' | sudo tee /var/www/healthcare/frontend/current/index.html
            fi

            # Verify HTTP and HTTPS
            echo "Verifying HTTP and HTTPS..."
            # Use -k to ignore SSL certificate validation
            if curl -sk -I http://localhost | grep -q "301 Moved Permanently"; then
              echo "✅ HTTP redirect works!"
            else
              echo "⚠️ HTTP redirect check failed, but continuing..."
              curl -v http://localhost || true
            fi

            if curl -sk -I https://localhost | grep -q "200 OK"; then
              echo "✅ HTTPS works!"
            else
              echo "⚠️ HTTPS check failed, but continuing..."
              curl -vk https://localhost || true
            fi

            # Start services with fixed container names
            echo "Starting services..."

            # Install any required build dependencies for bcrypt
            echo "Installing build dependencies for native modules..."
            if ! command -v python3 &> /dev/null || ! command -v g++ &> /dev/null || ! command -v make &> /dev/null; then
              sudo apt-get update
              sudo apt-get install -y python3 make g++ build-essential
            fi

            # Start Docker services
            docker compose -f docker-compose.prod.yml up -d --force-recreate --build

            # Manually generate Prisma client in the API container to ensure it's available
            echo "Generating Prisma client in API container..."
            docker exec latest-api sh -c "npx prisma generate --schema=/app/src/shared/database/prisma/schema.prisma" || true

            # Wait for containers to be healthy
            echo "Waiting for containers to be healthy..."
            for container in latest-api latest-postgres latest-redis latest-redis-commander; do
              echo "Waiting for $container to be healthy..."
              for i in {1..30}; do
                if docker ps --filter "name=$container" --format "{{.Status}}" | grep -q "healthy"; then
                  echo "$container is healthy"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "Error: $container failed to become healthy"
                  docker logs $container
                  exit 1
                fi
                echo "Attempt $i/30: Waiting for $container to be healthy..."
                sleep 10
              done
            done

            # Configure firewall to allow traffic on ports
            echo "Configuring firewall..."
            sudo ufw allow 80/tcp
            sudo ufw allow 443/tcp
            sudo ufw allow 8088/tcp
            sudo ufw allow 8082/tcp

            # Update current deployment symlink
            cd ${{ env.DEPLOY_PATH }}
            ln -sfn releases/${{ github.sha }} current

            echo "Deployment completed successfully!"
            echo "API should be accessible at:"
            echo "HTTPS (Domain): https://api.ishswami.in"
            echo "HTTP (Domain): http://api.ishswami.in"
            echo "HTTPS (IP): https://${{ env.SERVER_IP }}"
            echo "HTTP (IP): http://${{ env.SERVER_IP }}"
            echo "API Documentation: https://api.ishswami.in/docs"
            echo "Bull Queue Dashboard: https://api.ishswami.in/queue-dashboard"
            echo "Redis Commander: https://api.ishswami.in/redis-commander/"
            echo "PgAdmin: https://api.ishswami.in/pgadmin/"
            echo "Prisma Studio: https://api.ishswami.in/prisma/"
            echo "Health Check: https://api.ishswami.in/health"
            echo "============================================="

            # Test API health
            echo "Testing API health..."
            curl -v http://localhost:8088/health

            echo "All services are healthy!"

            # Apply Nginx changes and restart API
            echo "Applying Nginx changes and restarting API..."
            sudo systemctl reload nginx || sudo systemctl restart nginx

            # Ensure ports are properly opened in firewall
            echo "Ensuring firewall allows necessary ports..."
            sudo ufw status | grep "8088" || sudo ufw allow 8088/tcp
            sudo ufw status | grep "5555" || sudo ufw allow 5555/tcp
            sudo ufw status | grep "8082" || sudo ufw allow 8082/tcp

            # Update Nginx configuration for production environment
            echo "Updating Nginx configuration for production..."
            # Disable pgAdmin in production by commenting out its location block
            if [ -f "/etc/nginx/conf.d/server.conf" ]; then
              sudo sed -i '/location \/pgadmin\/ {/,/}/s/^/#/' /etc/nginx/conf.d/server.conf
            fi

            # Update service URLs in environment file
            sed -i "s|REDIS_COMMANDER_URL=.*|REDIS_UI_URL=/redis-ui|g" .env.production
            sed -i "s|SOCKET_URL=.*|SOCKET_URL=/socket|g" .env.production
            sed -i "s|PRISMA_STUDIO_URL=.*|PRISMA_STUDIO_URL=/prisma|g" .env.production
            sed -i "s|PGADMIN_URL=.*|#PGADMIN_URL is disabled in production|g" .env.production
            echo "LOGGER_URL=/logger" >> .env.production

            # Ensure Prisma Studio is running
            echo "Checking Prisma Studio status..."
            if ! docker exec latest-api netstat -tulpn | grep -q ":5555"; then
              echo "Prisma Studio not detected, attempting to start it..."
              docker exec latest-api sh -c "cd /app && BROWSER=none npx prisma studio --schema=/app/src/shared/database/prisma/schema.prisma --hostname 0.0.0.0 --port 5555 &"
              sleep 5
              
              if docker exec latest-api netstat -tulpn | grep -q ":5555"; then
                echo "✅ Prisma Studio successfully started"
              else
                echo "⚠️ Prisma Studio failed to start, check logs for details"
                docker logs latest-api | tail -50
              fi
            else
              echo "✅ Prisma Studio is already running"
            fi

            # Restart the API container to apply environment changes
            docker restart latest-api

            # Wait for the API to be healthy again
            echo "Waiting for the API to be healthy after restart..."
            for i in {1..10}; do
                if curl -s http://localhost:8088/health | grep -q '"status":"healthy"'; then
                    echo "✅ API is healthy after restart!"
                    break
                fi
                echo "Waiting for API health check ($i/10)..."
                sleep 3
            done

            # Final verification step - check if API is actually accessible
            echo "Performing final verification of the API..."
            # Check the actual health endpoint directly
            echo "Checking API health endpoint directly..."
            curl -v http://localhost:8088/health

            # Verify all services are accessible through Nginx
            echo "Verifying Nginx routing to services..."
            echo "Testing API health through Nginx..."
            curl -sk https://api.ishswami.in/health || echo "⚠️ API health through Nginx failed"

            echo "Testing Swagger docs through Nginx..."
            curl -sk -I https://api.ishswami.in/docs | grep "200" && echo "✅ Swagger docs accessible" || echo "⚠️ Swagger docs test failed"

            echo "Testing Bull Queue Dashboard through Nginx..."
            curl -sk -I https://api.ishswami.in/queue-dashboard | grep "200\|301\|302" && echo "✅ Bull Dashboard accessible" || echo "⚠️ Bull Dashboard test failed"

            echo "Testing Redis Commander through Nginx..."
            curl -sk -I https://api.ishswami.in/redis-ui/ | grep "200\|301\|302" && echo "✅ Redis Commander accessible" || echo "⚠️ Redis Commander test failed"

            echo "Testing Logger through Nginx..."
            curl -sk -I https://api.ishswami.in/logger/ | grep "200\|301\|302" && echo "✅ Logger accessible" || echo "⚠️ Logger test failed"

            echo "Testing Prisma Studio through Nginx..."
            curl -sk -I https://api.ishswami.in/prisma/ | grep "200\|301\|302" && echo "✅ Prisma Studio accessible" || echo "⚠️ Prisma Studio test failed"

            echo "Testing WebSocket through Nginx..."
            curl -sk -I https://api.ishswami.in/socket/ | grep "200\|301\|302\|400" && echo "✅ WebSocket endpoint accessible" || echo "⚠️ WebSocket endpoint test failed"

            # Display container status
            echo "Docker container status:"
            docker ps

            # Check container logs for any issues
            echo "Latest API container logs:"
            docker logs latest-api --tail 20

            echo "All services are healthy!"

  post-deployment-verification:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Verify domain
        run: |
          echo "Verifying domain resolution for api.ishswami.in..."

          # Check DNS resolution
          if ! nslookup api.ishswami.in > /dev/null 2>&1; then
            echo "Warning: Domain api.ishswami.in is not resolving"
            echo "Check your DNS configuration"
          fi

      - name: Verify application health
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e

            echo "Verifying application health..."

            # Check if API is responding at all
            if ! curl -s http://localhost:8088/health > /tmp/health_response; then
              echo "Error: API health endpoint unreachable"
              docker logs latest-api --tail 50
              exit 1
            fi

            # Display the API health response for debugging
            echo "API Health Response:"
            cat /tmp/health_response

            # Check status - accepting various success indicators
            if grep -q "ok\|status.*up\|\"status\":\"ok\"\|\"status\": \"ok\"" /tmp/health_response; then
              echo "API health check passed"
            else
              echo "Error: API health check failed - unexpected response"
              docker logs latest-api --tail 50
              exit 1
            fi

            # Check Redis Commander
            echo "Checking Redis Commander..."
            if ! curl -s http://localhost:8082 | grep -q "Redis Commander"; then
              echo "Error: Redis Commander health check failed"
              exit 1
            fi

            # Check database connection
            if ! docker exec latest-postgres pg_isready -U postgres; then
              echo "Error: Database health check failed"
              exit 1
            fi

            # Check Redis connection
            if ! docker exec latest-redis redis-cli ping | grep -q "PONG"; then
              echo "Error: Redis health check failed"
              exit 1
            fi

            echo "All services are healthy!"

      - name: Update deployment status success
        if: success()
        run: |
          echo "Deployment successful"

      - name: Update deployment status failure
        if: failure()
        run: |
          echo "Deployment failed"

  rollback:
    if: failure() && (needs.deploy.result == 'failure' || needs.post-deployment-verification.result == 'failure')
    needs: [deploy, post-deployment-verification, create-deployment]
    runs-on: ubuntu-latest
    steps:
      - name: Rollback deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Ensure backup directory exists
            mkdir -p backups

            # Check if current deployment exists
            if [ -d "current" ] && [ -f "current/docker-compose.prod.yml" ]; then
              echo "Current deployment found, attempting to restore from previous version if available"
              
              # Check if backup exists
              if [ -f backups/latest_backup ]; then
                timestamp=$(cat backups/latest_backup)
                echo "Rolling back to backup from $timestamp"
                
                # Stop current services
                cd current
                docker compose -f docker-compose.prod.yml down --remove-orphans || true
                cd ..
                
                # Clean up Docker resources
                echo "Cleaning up Docker resources..."
                docker system prune -f
                docker volume prune -f
                docker network prune -f
                
                # Restore from backup
                rm -rf current
                cp -r backups/$timestamp current/
                
                # Start services from backup
                cd current
                docker compose -f docker-compose.prod.yml up -d
                
                # Wait for API to be healthy
                echo "Waiting for API to be healthy..."
                attempt=1
                max_attempts=30
                while [ $attempt -le $max_attempts ]; do
                  curl -s http://localhost:8088/health > /tmp/health_response
                  if grep -q "ok\|status.*up\|\"status\":\"ok\"\|\"status\": \"ok\"" /tmp/health_response; then
                    echo "API service is healthy after rollback"
                    echo "Response: $(cat /tmp/health_response)"
                    break
                  fi
                  echo "Attempt $attempt/$max_attempts: Waiting for API service..."
                  echo "Current response: $(cat /tmp/health_response)"
                  sleep 10
                  attempt=$((attempt + 1))
                done
                
                if [ $attempt -gt $max_attempts ]; then
                  echo "Error: API service failed to become healthy after rollback"
                  docker logs latest-api
                  exit 1
                fi
                
                echo "Rollback completed successfully"
              else
                echo "No backup found for rollback, but current deployment exists"
                echo "No action taken - keeping current deployment"
                exit 0
              fi
            else
              echo "No current deployment found, nothing to roll back"
              exit 0
            fi

      - name: Update deployment status success
        if: success()
        run: |
          echo "Rollback successful"

      - name: Update deployment status failure
        if: failure()
        run: |
          echo "Rollback failed"
