name: Deploy Healthcare Backend

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  actions: read
  deployments: write

env:
  DOCKER_COMPOSE_VERSION: v2.20.2
  SERVER_HOST: api.ishswami.in
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DEPLOY_PATH: /var/www/healthcare/backend
  IMAGE_NAME: healthcare-backend
  SERVER_IP: 82.208.20.16
  DOMAIN: api.ishswami.in
  FRONTEND_DOMAIN: ishswami.in

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test -- --passWithNoTests

  pre-deployment-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check domain DNS
        run: |
          echo "Checking DNS for ${{ env.DOMAIN }}..."
          if ! nslookup ${{ env.DOMAIN }} > /dev/null 2>&1; then
            echo "Warning: Domain ${{ env.DOMAIN }} DNS resolution failed"
            echo "Please ensure domain is properly configured"
          fi

      - name: Check server connectivity
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            echo "Checking system resources..."
            df -h
            free -m
            docker system df

            echo "Checking required ports..."
            for port in 80 443 8088 5432 6379 8082; do
              if netstat -tuln | grep -q ":$port "; then
                echo "Warning: Port $port is already in use"
                netstat -tuln | grep ":$port "
              fi
            done

            echo "Checking Docker status..."
            docker info

            echo "Checking existing containers..."
            docker ps -a

            echo "Checking nginx configuration..."
            if [ -f /etc/nginx/nginx.conf ]; then
              nginx -t || echo "Warning: Nginx configuration test failed"
            fi

  build-and-push:
    needs: [test, pre-deployment-check]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker images
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          docker build -t $DOCKERHUB_USERNAME/healthcare-backend:latest .
          docker push $DOCKERHUB_USERNAME/healthcare-backend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Prepare deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            echo "Creating backup of existing configuration..."
            cd ${{ env.DEPLOY_PATH }}
            if [ -f docker-compose.prod.yml ]; then
              cp docker-compose.prod.yml docker-compose.prod.yml.backup
            fi
            if [ -f .env.production ]; then
              cp .env.production .env.production.backup
            fi

      - name: Copy deployment files
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          source: "docker-compose.prod.yml,.env.production,nginx/"
          target: ${{ env.DEPLOY_PATH }}
          strip_components: 0
          overwrite: true

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          envs: DOCKERHUB_USERNAME,DOCKERHUB_TOKEN
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "Performing pre-deployment checks..."

            # Check disk space
            DISK_SPACE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_SPACE" -gt 85 ]; then
              echo "Warning: Low disk space. Current usage: ${DISK_SPACE}%"
              docker system prune -f
            fi

            # Check Docker daemon
            if ! docker info > /dev/null 2>&1; then
              echo "Error: Docker daemon is not running"
              exit 1
            fi

            # Login to Docker Hub
            echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

            # Create required directories
            mkdir -p logs nginx/conf.d nginx/dhparam

            # Generate DH parameters if not exists
            if [ ! -f nginx/dhparam/dhparam.pem ]; then
              echo "Generating DH parameters..."
              openssl dhparam -out nginx/dhparam/dhparam.pem 2048
            fi

            # Basic Nginx syntax validation (skip upstream checks)
            if [ -f nginx/conf.d/default.conf ]; then
              echo "Validating basic Nginx configuration syntax..."
              docker run --rm \
                -v $(pwd)/nginx/conf.d:/etc/nginx/conf.d:ro \
                nginx:latest \
                nginx -t -c /etc/nginx/nginx.conf || echo "Warning: Nginx configuration test failed (this may be expected if containers are not running)"
            fi

            # Create docker network if not exists
            docker network create nginx-proxy || true

            # Check and stop conflicting services
            echo "Checking for port conflicts..."
            for port in 80 443 8088 5432 6379 8082; do
              if netstat -tuln | grep -q ":$port "; then
                echo "Stopping service using port $port..."
                fuser -k $port/tcp || true
              fi
            done

            # Pull latest images
            echo "Pulling latest images..."
            docker-compose -f docker-compose.prod.yml pull

            # Stop current deployment (if exists)
            echo "Stopping current deployment..."
            docker-compose -f docker-compose.prod.yml down --remove-orphans || true

            # Start new deployment
            echo "Starting new deployment..."
            DOCKERHUB_USERNAME=$DOCKERHUB_USERNAME docker-compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy with timeout
            timeout=360
            start_time=$(date +%s)

            echo "Waiting for services to start up (initial delay: 60s)..."
            sleep 60

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              
              if [ $elapsed -gt $timeout ]; then
                echo "Timeout waiting for services to be healthy"
                docker-compose -f docker-compose.prod.yml logs
                exit 1
              fi
              
              # Check all required services health
              api_healthy=$(docker ps --filter "name=healthcarebackend-api-1" --format "{{.Status}}" | grep -q "healthy" && echo "yes" || echo "no")
              postgres_healthy=$(docker ps --filter "name=postgres" --format "{{.Status}}" | grep -q "healthy" && echo "yes" || echo "no")
              redis_healthy=$(docker ps --filter "name=healthcarebackend-redis-1" --format "{{.Status}}" | grep -q "healthy" && echo "yes" || echo "no")
              nginx_running=$(docker ps --filter "name=nginx-proxy" --format "{{.Status}}" | grep -q "Up" && echo "yes" || echo "no")
              
              if [ "$api_healthy" = "yes" ] && [ "$postgres_healthy" = "yes" ] && [ "$redis_healthy" = "yes" ] && [ "$nginx_running" = "yes" ]; then
                echo "All services are healthy!"
                break
              fi
              
              echo "Waiting for services to be healthy... ($elapsed seconds elapsed)"
              echo "API: $api_healthy, PostgreSQL: $postgres_healthy, Redis: $redis_healthy, Nginx: $nginx_running"
              sleep 20
            done

            # Verify domain accessibility
            echo "Verifying domain accessibility..."
            if ! curl -f -s -k https://${{ env.DOMAIN }}/health > /dev/null; then
              echo "Warning: Unable to access API through domain. Checking local access..."
              if wget --spider -q http://localhost:8088/health; then
                echo "API is accessible locally but not through domain. Check DNS and Nginx configuration."
                exit 1
              else
                echo "API is not accessible locally either. Deployment failed."
                docker-compose -f docker-compose.prod.yml logs
                exit 1
              fi
            fi

            echo "Deployment successful - All checks passed!"
            exit 0

  rollback:
    if: failure() && github.event_name == 'push'
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Rollback deployment
        uses: appleboy/ssh-action@master
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          envs: DOCKERHUB_USERNAME
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "Starting rollback procedure..."

            # Restore configuration backups if they exist
            if [ -f docker-compose.prod.yml.backup ]; then
              mv docker-compose.prod.yml.backup docker-compose.prod.yml
            fi
            if [ -f .env.production.backup ]; then
              mv .env.production.backup .env.production
            fi

            # Get the previous image
            PREV_IMAGE=$(docker images $DOCKERHUB_USERNAME/healthcare-backend --format "{{.ID}} {{.CreatedAt}}" | sort -k2 -r | awk 'NR==2{print $1}')

            if [ -z "$PREV_IMAGE" ]; then
              echo "No previous image found for rollback"
              exit 1
            fi

            echo "Rolling back to previous image: $PREV_IMAGE"

            # Stop current deployment
            docker-compose -f docker-compose.prod.yml down --remove-orphans || true

            # Start with previous image
            docker tag $PREV_IMAGE $DOCKERHUB_USERNAME/healthcare-backend:latest
            DOCKERHUB_USERNAME=$DOCKERHUB_USERNAME docker-compose -f docker-compose.prod.yml up -d

            # Wait for services with timeout
            timeout=300
            start_time=$(date +%s)

            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              
              if [ $elapsed -gt $timeout ]; then
                echo "Timeout waiting for rollback services to be healthy"
                docker-compose -f docker-compose.prod.yml logs
                exit 1
              fi
              
              if docker ps --filter "name=healthcarebackend-api-1" --format "{{.Status}}" | grep -q "healthy"; then
                echo "Rollback successful - services are healthy"
                break
              fi
              
              echo "Waiting for rollback services to be healthy... ($elapsed seconds elapsed)"
              sleep 20
            done

            # Verify API health after rollback
            if wget --spider -q http://localhost:8088/health; then
              echo "Rollback successful - API is healthy"
              exit 0
            else
              echo "Rollback failed - API health check failed"
              docker-compose -f docker-compose.prod.yml logs
              exit 1
            fi
