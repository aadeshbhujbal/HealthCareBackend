name: Deploy Healthcare Backend

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  actions: read
  deployments: write

env:
  DOCKER_COMPOSE_VERSION: v2.20.2
  SERVER_HOST: api.ishswami.in
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  DEPLOY_PATH: /var/www/healthcare/backend
  SERVER_IP: 82.208.20.16
  DOMAIN: api.ishswami.in
  FRONTEND_DOMAIN: ishswami.in
  SSL_EMAIL: aadeshbhujbal99@gmail.com
  NODE_ENV: production
  API_CONTAINER: latest-api
  POSTGRES_CONTAINER: latest-postgres
  REDIS_CONTAINER: latest-redis
  REDIS_COMMANDER_CONTAINER: latest-redis-commander
  NETWORK_NAME: app-network

jobs:
  pre-deployment-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check domain DNS and SSL
        run: |
          echo "Checking DNS for ${{ env.DOMAIN }}..."
          if ! nslookup ${{ env.DOMAIN }} > /dev/null 2>&1; then
            echo "Warning: Domain ${{ env.DOMAIN }} DNS resolution failed"
            echo "Please ensure domain is properly configured"
            exit 1
          fi

          echo "Checking SSL certificate expiry..."
          expiry=$(echo | openssl s_client -servername ${{ env.DOMAIN }} -connect ${{ env.DOMAIN }}:443 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          if [ ! -z "$expiry" ]; then
            expiry_sec=$(date -d "$expiry" +%s)
            now_sec=$(date +%s)
            days_left=$(( ($expiry_sec - $now_sec) / 86400 ))
            if [ $days_left -lt 30 ]; then
              echo "Warning: SSL certificate will expire in $days_left days"
            fi
          fi

      - name: Check server connectivity and resources
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            echo "Checking system resources..."
            df -h
            free -m
            docker system df

            echo "Checking Docker status..."
            if ! docker info > /dev/null 2>&1; then
              echo "Docker is not running!"
              exit 1
            fi

            echo "Checking required ports..."
            for port in 8088 5432 6379 8082; do
              if netstat -tuln | grep -q ":$port "; then
                echo "Warning: Port $port is already in use"
                netstat -tuln | grep ":$port "
              fi
            done

            echo "Checking disk space..."
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 85 ]; then
              echo "Warning: Disk usage is above 85%"
              df -h /
            fi

            echo "Checking SSL certificate paths..."
            for dir in "/etc/nginx/ssl" "/app/ssl"; do
              if [ ! -d "$dir" ]; then
                echo "Creating $dir directory..."
                sudo mkdir -p $dir
                sudo chmod 755 $dir
              fi
            done

  create-deployment:
    needs: [pre-deployment-check]
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.create_deployment.outputs.deployment_id }}
    steps:
      - name: Create GitHub deployment
        id: create_deployment
        uses: actions/github-script@v6
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.id;

  deploy:
    needs: create-deployment
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Create backup and cleanup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Create backup directory with timestamp
            timestamp=$(date +%Y%m%d_%H%M%S)
            mkdir -p backups/$timestamp

            # Stop and backup current deployment if it exists
            if [ -d "current" ] && [ -f "current/docker-compose.prod.yml" ]; then
              echo "Stopping current deployment..."
              cd current
              docker compose -f docker-compose.prod.yml down --remove-orphans || true
              cd ..

              echo "Creating backup..."
              cp -r current/* backups/$timestamp/ 2>/dev/null || true
              echo $timestamp > backups/latest_backup
            else
              echo "No current deployment found, proceeding with fresh deployment..."
            fi

            # Clean up Docker resources
            echo "Cleaning up Docker resources..."
            docker system prune -f
            docker volume prune -f

            # Remove any existing containers with conflicting names
            for container in latest-redis latest-postgres latest-api latest-redis-commander; do
              if docker ps -a --format '{{.Names}}' | grep -q "^$container$"; then
                echo "Removing existing container: $container"
                docker rm -f $container || true
              fi
            done

            # Create necessary Docker network if it doesn't exist
            echo "Creating Docker network..."
            if ! docker network inspect app-network > /dev/null 2>&1; then
              docker network create app-network --subnet=172.18.0.0/16
            fi

            # Create necessary directories if they don't exist
            mkdir -p current
            mkdir -p releases
            mkdir -p backups

      - name: Prepare deployment files
        run: |
          echo "Preparing files for deployment..."
          echo "Current directory: $PWD"
          echo "GitHub workspace: $GITHUB_WORKSPACE"

          # Create a temporary deployment directory
          rm -rf deploy_temp
          mkdir -p deploy_temp

          # Copy required directories and files
          echo "Copying deployment files..."
          cp -r src scripts deploy_temp/
          cp docker-compose.prod.yml .env.production Dockerfile package*.json tsconfig*.json deploy_temp/

      - name: Copy deployment files
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          source: "deploy_temp/*"
          target: "${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}"
          strip_components: 1
          overwrite: true
          rm: false

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}

            # Configure host to resolve api.ishswami.in to localhost
            echo "Configuring hosts file for api.ishswami.in..."
            if ! grep -q "api.ishswami.in" /etc/hosts; then
              echo "127.0.0.1 api.ishswami.in" | sudo tee -a /etc/hosts
            fi

            # Handle Docker network
            echo "Setting up Docker network..."
            if ! docker network inspect app-network > /dev/null 2>&1; then
              echo "Creating Docker network app-network..."
              docker network create app-network --subnet=172.18.0.0/16
            fi

            # Start services with fixed container names
            echo "Starting services..."
            docker compose -f docker-compose.prod.yml up -d --force-recreate

            # Wait for containers to be healthy
            echo "Waiting for containers to be healthy..."
            for container in latest-api latest-postgres latest-redis latest-redis-commander; do
              echo "Waiting for $container to be healthy..."
              for i in {1..30}; do
                if docker ps --filter "name=$container" --format "{{.Status}}" | grep -q "healthy"; then
                  echo "$container is healthy"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "Error: $container failed to become healthy"
                  docker logs $container
                  exit 1
                fi
                echo "Attempt $i/30: Waiting for $container to be healthy..."
                sleep 10
              done
            done

            # Configure firewall to allow traffic on port 8088
            echo "Configuring firewall..."
            sudo ufw allow 8088/tcp
            sudo ufw allow 8082/tcp

            # Update current deployment symlink
            cd ${{ env.DEPLOY_PATH }}
            ln -sfn releases/${{ github.sha }} current

            echo "Deployment completed successfully!"
            echo "API should be accessible at http://api.ishswami.in:8088"
            echo "Redis Commander should be accessible at http://api.ishswami.in:8082"

            # Test API health
            echo "Testing API health..."
            curl -v http://api.ishswami.in:8088/health

  post-deployment-verification:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Verify domain
        run: |
          echo "Verifying domain resolution for api.ishswami.in..."

          # Check DNS resolution
          if ! nslookup api.ishswami.in > /dev/null 2>&1; then
            echo "Warning: Domain api.ishswami.in is not resolving"
            echo "Check your DNS configuration"
          fi

      - name: Verify application health
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e

            echo "Verifying application health..."

            # Check API health endpoint
            if ! curl -s http://api.ishswami.in:8088/health | grep -q "ok"; then
              echo "Error: API health check failed"
              docker logs latest-api --tail 50
              exit 1
            fi

            # Check Redis Commander
            if ! curl -s http://api.ishswami.in:8082 | grep -q "Redis Commander"; then
              echo "Error: Redis Commander health check failed"
              exit 1
            fi

            # Check database connection
            if ! docker exec latest-postgres pg_isready -U postgres; then
              echo "Error: Database health check failed"
              exit 1
            fi

            # Check Redis connection
            if ! docker exec latest-redis redis-cli ping | grep -q "PONG"; then
              echo "Error: Redis health check failed"
              exit 1
            fi

            echo "All services are healthy!"

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.create-deployment.outputs.deployment_id }},
              state: status,
              environment: 'production'
            });

  rollback:
    if: failure() && (needs.deploy.result == 'failure' || needs.post-deployment-verification.result == 'failure')
    needs: [deploy, post-deployment-verification, create-deployment]
    runs-on: ubuntu-latest
    steps:
      - name: Rollback deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            if [ -f backups/latest_backup ]; then
              timestamp=$(cat backups/latest_backup)
              echo "Rolling back to backup from $timestamp"

              # Stop current services
              if [ -d "current" ]; then
                cd current
                docker compose -f docker-compose.prod.yml down --remove-orphans || true
                cd ..
              fi

              # Clean up Docker resources
              echo "Cleaning up Docker resources..."
              docker system prune -f
              docker volume prune -f
              docker network prune -f

              # Restore from backup
              rm -rf current
              cp -r backups/$timestamp current/

              # Start services from backup
              cd current
              docker compose -f docker-compose.prod.yml up -d

              # Wait for API to be healthy
              echo "Waiting for API to be healthy..."
              attempt=1
              max_attempts=30
              while [ $attempt -le $max_attempts ]; do
                if curl -s http://api.ishswami.in:8088/health | grep -q "ok"; then
                  echo "API service is healthy after rollback"
                  break
                fi
                echo "Attempt $attempt/$max_attempts: Waiting for API service..."
                sleep 10
                attempt=$((attempt + 1))
              done

              if [ $attempt -gt $max_attempts ]; then
                echo "Error: API service failed to become healthy after rollback"
                docker logs latest-api
                exit 1
              fi

              echo "Rollback completed successfully"
            else
              echo "No backup found for rollback"
              exit 1
            fi

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.create-deployment.outputs.deployment_id }},
              state: status,
              environment: 'production'
            });
